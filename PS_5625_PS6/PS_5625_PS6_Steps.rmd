---
title: 'PS 5625 PS #6 Development File'
author: "Patrick Edwards"
date: "5/7/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE)
```

PRELIMINARY: Load package `Rcpp`:
```{r}
#install.packages("Rcpp")
library(Rcpp)
```

# PRELIMINARY: Start with assumption that all models are weighted equally.

## Load in test data.
```{r}
library(EBMAforecast)
df <- EBMAforecast::presidentialForecast
y <- df$Actual
```


## R code.
```{r eval = FALSE}
## Find number of models:
K <- dim(df)[2] - 1

## Find the number of observations (in this case, presidential elections):
T <- dim(df)[1]

## Define w_hat with all models weighted equally.
w_hat <- replicate(K,1/K)
```

# STEP (1): Write an Rcpp function that will calculate the answer to Equation (2). The output will be a matrix.

## Corresponding R Code (From in-class assignment)
```{r eval = FALSE}
z_hat <- (w_hat * dnorm(y[t], df[t,k], 1))/(sum(w_hat * dnorm(y[t], df[t,k], 1)))
```

## Rcpp Code

**NOTE**: this is largely from `Rcpp` code that my group created for in-class assignment #21.

```{r rcppVersion}
library(Rcpp)
library(RcppArmadillo)
# Code for Equation 2:
## NOTE: I base this code on in-class assignment #21. Our group created the cpp code that solved step (1) & step(2)


cppFunction('
  NumericMatrix Z_H(NumericMatrix x, 
    NumericVector y, 
    NumericVector weights, 
    double sd
  ){
  
  //Start here
  int rows = x.nrow();
  NumericMatrix dNormal(x);
  NumericMatrix out(x);
  
  //Calculates dnorm like for the R portion of inclass21:
  for (int l = 0; l < x.nrow(); ++l) {
    for (int k = 0; k < x.ncol(); ++k) {
      double datNumber = R::dnorm(y[l], x(l,k), sd, FALSE);
      dNormal(l,k) =  datNumber; // 
    }
  }
  
  //weights rows before the summation.
  NumericVector val(rows);
  for (int l = 0; l < rows; ++l) {
  
    double rowSum = 0;
    for (int k = 0; k < dNormal.ncol(); ++k) {
      rowSum += weights[k] * dNormal(l,k);
    }
  val[l] = rowSum;
  }
  
  
  // Calculates Z_H value.
  for (int l = 0; l < x.nrow(); ++l) {
    for (int k = 0; k < x.ncol(); ++k) {
      out(l,k) =  weights[k] * dNormal(l,k) / val[l]; // 
    }
  }
  
  // Equivalent to return() in R.
  return out;
}')
```


# STEP (2): Write an Rcpp function that will calculate the answer to Equation (3). The output will be a vector.

## Corresponding R Code (From in-class assignment)

```{r eval = FALSE}
## NOTE 1: input `z_hat` and output `w_hat` are vectors of `K` elements.
## NOTE 2: `T = dim(df)[1]`, or the number of all presidential elections in sample.
w_hat <- sum(z_hat)/T
```

## Rcpp Code

```{r rcppVersion}
## NOTE: I base this code on in-class assignment #21. Our group created the cpp code that solved step(2)
# Input includes Z_H output.


cppFunction('NumericMatrix W_H(NumericMatrix x, NumericVector y, NumericVector weights, double sd){
  int rows = x.nrow();
  NumericMatrix dNormal(x);
  NumericMatrix out(x);

  for (int i = 0; i < x.nrow(); ++i) {
    for (int j = 0; j < x.ncol(); ++j) {
      double datNumber = R::dnorm(y[i], x(i,j), sd, FALSE);
      dNormal(i,j) =  datNumber; // 
    }
  }

  NumericVector sums(rows);
  for (int i = 0; i < rows; ++i) {
  
    double rowSum = 0;
    for (int j = 0; j < dNormal.ncol(); ++j) {
      rowSum += weights[j] * dNormal(i,j);
    }
  sums[i] = rowSum;
  }
  
  for (int i = 0; i < x.nrow(); ++i) {
    for (int j = 0; j < x.ncol(); ++j) {
      out(i,j) =  weights[j] * dNormal(i,j) / sums[i]; // 
    }
  }

  return out;
}')
```



# STEP (3): Write an Rcpp function that will complete the entire algorithm.

## Corresponding R Code (From in-class assignment)

```{r eval = FALSE}
# PRELIMINARY 1: Number of models:
K <- dim(df)[2] - 1

# PRELIMINARY 2: Number of observations:
Ti <- dim(df)[1]

# PRELIMINARY 3: Create function that combines steps (2) & (3):
steps23 <- function(df = df, w_hat = wHat_it[i-1,]){
  y <- df[[7]] # Create vector of outcome variables.
  M <- df[,1:K] # create matrix of models.
  K <- dim(df)[2] - 1 # Number of models.
  Ti <- dim(df)[1] #Number of observations
  # Create dnorm object for step 2:
  dnormal <- t(
    sapply(
      X = 1:Ti,
      FUN = function(t){
        dnorm(
          y[t],
          sapply(
            X = 1:K,
            FUN = function(k){df[t,k]}
            ),
          sd = 1
          )
        }
      )
    )
  # Do step 2 function:
  z_hats <- t(
    sapply(
      X = 1:Ti,
      FUN = function(t){
        (w_hat * dnormal[t,])/(sum(w_hat * dnormal[t,]))
        }
      )
    )
  # Do step 3 function:
  w_hat2 <- sapply(
    X = 1:K,
    FUN = function(k){
      sum(z_hats[,k])/Ti
    }
  )
  return(w_hat2)
}

# PRELIMINARY 4: create matrix to collect iterations data. It needs to have 21
# rows for the initial w_hat and the 20 iterations of w_hat.
itnum <- 20 # Number of iterations
wHat_it <- matrix(
  data = NA,
  nrow = itnum + 1,
  ncol = K
  )
colnames(wHat_it) <- c("Campbell",
                       "Lewis-Beck",
                       "EWT2C2",
                       "Fair",
                       "Hibbs",
                       "Abramowitz"
                       )
rownames(wHat_it) <- 0:itnum

# STEP 1: Define w_hat with all models weighted equally.
wHat_it[1,] <- replicate(K,1/K)

# Steps 2-4 (ITERATION):
i <- 2 
while(i <= itnum + 1){
  wHat_it[i,] <- steps23(df = df, w_hat = wHat_it[i-1,])
  print(i)
  i = i + 1
}

# FINAL ITERATION:
wHat_it[tail(itnum,1),]
```

## Rcpp Code

```{r rcppVersion}
# ALso loosly based on in-class assignment.

src <- "#include <Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]

NumericMatrix W_H(NumericMatrix x, NumericVector y, NumericVector weights, double sd){
  int rows = x.nrow();
  NumericMatrix dNormal(x);
  NumericMatrix out(x);

  for (int i = 0; i < x.nrow(); ++i) {
    for (int j = 0; j < x.ncol(); ++j) {
      double datNumber = R::dnorm(y[i], x(i,j), sd, FALSE);
      dNormal(i,j) =  datNumber; // 
    }
  }

  NumericVector sums(rows);
  for (int i = 0; i < rows; ++i) {
  
    double rowSum = 0;
    for (int j = 0; j < dNormal.ncol(); ++j) {
      rowSum += weights[j] * dNormal(i,j);
    }
  sums[i] = rowSum;
  }
  
  for (int i = 0; i < x.nrow(); ++i) {
    for (int j = 0; j < x.ncol(); ++j) {
      out(i,j) =  weights[j] * dNormal(i,j) / sums[i]; // 
    }
  }

  return out;
}

// [[Rcpp::export]]
NumericVector W_H(NumericMatrix zHat) {
  int rows = zHat.nrow();
  int cols = zHat.ncol();
  NumericVector out(cols);
  
  for (int j = 0; j < zHat.ncol(); ++j) {
  
    double newWeight = 0;
    for (int i = 0; i < zHat.nrow(); ++i) {
      newWeight +=  zHat(i,j);
    }
  out[j] = newWeight / rows;
  }
  return out;
}

// [[Rcpp::export]]
NumericVector rCppEBMA(NumericMatrix x, NumericVector y, NumericVector weights, double sd, int iterations){
NumericMatrix w((iterations + 1), x.ncol());
w( 0 , _ ) = weights;

for (int i = 0; i < iterations; ++i){
  w((i + 1), _ ) = W_H(W_H(x, y, w(i, _ ), sd));
}

return w( iterations , _ );
}"

```



# STEP (4): Include one unit test per function.

**[STEP NOT COMPLETE]**


# STEP (5): Assemble the code as an R package.

```{r}
getwd()
setwd("~/")
library(usethis)
usethis::use_rcpp("C:/Users/edwar/Documents/LouisRcppEBMA")
# Create outside of github repository, then put it back in later.
#setwd("Documents")
#library(usethis)
#usethis::use_rcpp("RcppEBMA")
```


# STEP (6): Write a development .R file that demonstrates the packageâ€™s use.

**[STEP NOT COMPLETE]**




