}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
PlayGame <- function(x){
UseMethod("groomer")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice)
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list.
choice <- 1
class(choice) <- "door"
# (b). This object now has the class attribute `door`.
class(choice)
choice
# (b). Check that this function works for `door` objects:
PlayGame(choice)
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list.
choice <- 1
class(choice) <- "door"
# (b). This object now has the class attribute `door`.
class(choice)
choice
PlayGame <- function(x){
UseMethod("PlayGame")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice)
PlayGame(unclass(choice))
x <- 1
class(x)
PlayGame(x)
PlayGame(unclass(choice))
# (a). I create the method.
PlayGame <- function(x){
UseMethod("PlayGame")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice)
# (c). Check that this function does not work for non-`door` objects:
# PlayGame(unclass(choice))
# Error in UseMethod("PlayGame") :
#   no applicable method for 'PlayGame' applied to an object of class "c('double', 'numeric')"
# COMPLETED.
# (a). Make a construction function that allows the user to create a `door` object.
#       INCOMPLETE.
# (b). Make a validation function that checks whether the value in `door` is actually an integer.
validate_door <- function(x){
if(is.integer(x) == FALSE){
stop("ERROR: this object does not contain an integer value!")
}
return(x)
}
newObj <- validate_door(choice)
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list. Crucially, this must work with elements that are integer and numeric.
choice <- 1
# (b). This object now has the class attribute `door`.
class(choice)
choice2 <- as.integer(2)
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list. Crucially, this must work with elements that are integer and numeric.
choice1 <- 1
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list. Crucially, this must work with elements that are integer and numeric. I create two objects with whole number elements of both integer and numeric classes.
choice1 <- 1
choice2 <- as.integer(2)
class(choice1) <- "door"
class(choice2) <- "door"
# (b). This object now has the class attribute `door`.
class(choice1)
class(choice2)
choice1
choice2
# COMPLETED.
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list. Crucially, this must work with elements that are integer and numeric. I create two objects with whole number elements of both integer and numeric classes.
choice1 <- 1
choice2 <- as.integer(2)
class(choice1) <- "door"
class(choice2) <- "door"
# (b). This object now has the class attribute `door`.
class(choice1)
class(choice2)
choice1
choice2
# COMPLETED.
# (a). I create the method.
PlayGame <- function(x){
UseMethod("PlayGame")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice1)
PlayGame(choice2)
# (c). Check that this function does not work for non-`door` objects:
# PlayGame(unclass(choice))
# Error in UseMethod("PlayGame") :
#   no applicable method for 'PlayGame' applied to an object of class "c('double', 'numeric')"
# COMPLETED.
# (a). I create the method.
PlayGame <- function(x){
UseMethod("PlayGame")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice1)
PlayGame(choice2)
# (c). Check that this function does not work for non-`door` objects:
# PlayGame(unclass(choice))
# Error in UseMethod("PlayGame") :
#   no applicable method for 'PlayGame' applied to an object of class "c('double', 'numeric')"
# COMPLETED.
# (a). I create a list `choice` that consists of three objects 1, 2, & 3. I then assign the class `door` to this list. Crucially, this must work with elements that are integer and numeric. I create two objects with whole number elements of both integer and numeric classes.
choice1 <- 1
choice2 <- as.integer(1)
class(choice1) <- "door"
class(choice2) <- "door"
# (b). This object now has the class attribute `door`.
class(choice1)
class(choice2)
choice1
choice2
# COMPLETED.
# (a). I create the method.
PlayGame <- function(x){
UseMethod("PlayGame")
}
PlayGame.door <- function(x){
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (b). Check that this function works for `door` objects:
PlayGame(choice1)
PlayGame(choice2)
# (c). Check that this function does not work for non-`door` objects:
# PlayGame(unclass(choice))
# Error in UseMethod("PlayGame") :
#   no applicable method for 'PlayGame' applied to an object of class "c('double', 'numeric')"
# COMPLETED.
# (a). Make a construction function that allows the user to create a `door` object.
#       INCOMPLETE.
# (b). Make a validation function that checks whether the value in `door` is actually an integer.
validate_door <- function(x){
if(x%%1 != 0){
stop("ERROR: this object does not contain an integer value!")
}
return(x)
}
newObj <- validate_door(choice1)
newObj <- validate_door(choice2)
newObj
newObj
validate_door <- function(x){
if(x%%1 != 0){
stop("ERROR: this object does not contain an integer value!")
}
if(x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
new_door <- function(choiceOfDoor){
x <- choiceOfDoor
class(x) <- "door"
return(x)
}
new_door <- function(choiceOfDoor=as.numeric(sample(x = 1:3, size = 1))){
x <- choiceOfDoor
class(x) <- "door"
return(x)
}
new_door(x)
new_door()
new_door()
new_door()
new_door()
new_door(5)
# (aii). Check that the construction function works for `choiceOfDoor inputs:
test1 <- new_door(5)
test1
validObj1 <- new_door(1)
validObj2 <- new_door(3)
validObj3 <- new_door()
invalidObj1 <- new_door(-5)
invalidObj2 <- new_door(1.5)
invalidObj3 <- new_door("Seashells")
PlayGame(validObj1)
PlayGame(validObj2)
PlayGame(validObj3)
PlayGame(invalidObj1) #
validate_door <- function(x){
if(x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if(x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
PlayGame(invalidObj1) #
invalidObj1 <- new_door(-5)
# (ai). Make a construction function that allows the user to create a `door` object.
new_door <- function(choiceOfDoor=as.numeric(sample(x = 1:3, size = 1))){
x <- choiceOfDoor
class(x) <- "door"
return(x)
}
# note that the default value of choiceOfDoor is a random sample of the integers 1, 2, & 3. We can think of this as the game contestant randomly choosing between each door.
# (aii). Check that the construction function works for `choiceOfDoor inputs:
test1 <- new_door(2)
test1  # Interpretation: the game contestant chooses door 2.
test2 <- new_door()
test2  # Interpretation: the game contestant randomly chose between the three doors.
# Crucially, note that this constructor does not include validation checks: We can use nonsensical numbers. This is because its the validation function, not the construction function, that should check the validity of these values:
test3 <- new_door(5)
test3  # No sensible interpretation. Will be caught by the validity check.
# (bi). Make a validation function that checks whether the value in `door` is actually an integer.
validate_door <- function(x){
if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
newObj
newObj <- validate_door(choice2)
newObj
# Both work (i.e., neither throws an error).
# (c). Include the validation function in the original function.
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (cii). Use the constructor function to create valid & non-valid test objects. Then use these to test the new function that includes the validation function.
validObj1 <- new_door(1)
validObj2 <- new_door(3)
validObj3 <- new_door()
invalidObj1 <- new_door(-5)
invalidObj2 <- new_door(1.5)
invalidObj3 <- new_door("Seashells")
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
PlayGame(invalidObj1) #
validate_door <- function(x){
if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if(x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
}
if(x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
alidObj1 <- new_door(1)
validObj2 <- new_door(3)
validObj3 <- new_door()
invalidObj1 <- new_door(-5)
invalidObj2 <- new_door(1.5)
invalidObj3 <- new_door("Seashells")
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
PlayGame(invalidObj1) #
PlayGame(invalidObj2)
PlayGame(invalidObj3)
# (bi). Make a validation function that checks whether the value in `door` is actually an integer.
validate_door <- function(x){
if (is.numeric(x) | is.integer(x) | is.double(x)) {
stop("ERROR: this object does not contain a numeric, integer, or double element!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if (x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
} else if (x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
PlayGame(invalidObj1) #
PlayGame(invalidObj2)
PlayGame(invalidObj3)
PlayGame(validObj3) # Works properly.
PlayGame(validObj2) # Works properly.
validate_door <- function(x){
if (is.numeric(x) == TRUE | is.integer(x) == TRUE | is.double(x) == TRUE) {
stop("ERROR: this object does not contain a numeric, integer, or double element!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
validate_door <- function(x){
if (is.numeric(x) == FALSE | is.integer(x) == FALSE | is.double(x) == FALSE) {
stop("ERROR: this object does not contain a numeric, integer, or double element!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
validate_door <- function(x){
if (is.numeric(x) != TRUE | is.integer(x) != TRUE | is.double(x) != TRUE) {
stop("ERROR: this object does not contain a numeric, integer, or double element!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
validate_door <- function(x){
if (is.numeric(x) == FALSE) {
stop("ERROR: this object does not contain a numeric value!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
newObj
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if (x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
} else if (x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
validObj2 <- new_door(3L)
validObj2
class(validObj2[1])
validate_door <- function(x){
if (is.numeric(x[1]) == FALSE) {
stop("ERROR: this object does not contain a numeric value!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
newObj
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if (x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
} else if (x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (cii). Use the constructor function to create valid & non-valid test objects. Then use these to test the new function that includes the validation function.
validObj1 <- new_door(1)
validObj2 <- new_door(3L)
validObj3 <- new_door()
invalidObj1 <- new_door(-5)
invalidObj2 <- new_door(1.5)
invalidObj3 <- new_door("Seashells")
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
PlayGame(invalidObj1) #
PlayGame(invalidObj2)
PlayGame(invalidObj3)
# (ai). Make a construction function that allows the user to create a `door` object.
new_door <- function(choiceOfDoor=as.numeric(sample(x = 1:3, size = 1))){
x <- choiceOfDoor
class(x) <- "door"
return(x)
}
# note that the default value of choiceOfDoor is a random sample of the integers 1, 2, & 3. We can think of this as the game contestant randomly choosing between each door.
# (aii). Check that the construction function works for `choiceOfDoor inputs:
test1 <- new_door(2)
test1  # Interpretation: the game contestant chooses door 2.
test2 <- new_door()
test2  # Interpretation: the game contestant randomly chose between the three doors.
# Crucially, note that this constructor does not include validation checks: We can use nonsensical numbers. This is because its the validation function, not the construction function, that should check the validity of these values:
test3 <- new_door(5)
test3  # No sensible interpretation. Will be caught by the validity check.
# (bi). Make a validation function that checks whether the value in `door` is actually an integer.
validate_door <- function(x){
if (is.numeric(x[1]) == FALSE) {
stop("ERROR: this object does not contain a numeric value!")
} else if (x%%1 != 0){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
} else if (x < 1 | x > 3){
stop("ERROR: this object does not contain the integers 1, 2, or 3!")
}
return(x)
}
# (bii). Check that the validation function works for `door` objects that contain elements with integer and numeric classes:
newObj <- validate_door(choice1)
newObj
newObj <- validate_door(choice2)
newObj
# Both work (i.e., neither throws an error).
# (ci). Include the validation function in the original function.
PlayGame.door <- function(x){
x <- validate_door(x)
winningDoor <- as.numeric(sample(x = 1:3, size = 1))
if (x == winningDoor) {
print("Congratulations! You are the owner of a BRAND. NEW. CAR!")
} else if (x != winningDoor) {
print("How unfortunate, you got the goat. Our condolences :(")
}
}
# (cii). Use the constructor function to create valid & non-valid test objects. Then use these to test the new function that includes the validation function.
validObj1 <- new_door(1)
validObj2 <- new_door(3L)
validObj3 <- new_door()
invalidObj1 <- new_door(-5)
invalidObj2 <- new_door(1.5)
invalidObj3 <- new_door("Seashells")
PlayGame(validObj1) # Works properly.
PlayGame(validObj2) # Works properly.
PlayGame(validObj3) # Works properly.
# PlayGame(invalidObj1) # Throws correct error.
# PlayGame(invalidObj2) # Throws correct error.
# PlayGame(invalidObj3) # Throws correct error.
